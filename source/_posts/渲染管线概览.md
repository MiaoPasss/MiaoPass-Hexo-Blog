---
title: 渲染管线概览
date: 2025-08-14 17:45:38
categories: Graphics
tags: 
- Rendering pipeline
- Shader
---

![](p2.png "渲染图元") <br>

# CPU + GPU工作流程

1. 剔除，把一些不想看到的，或者看不到的东西排除掉
2. 确定物体的先后渲染顺序
3. 将对应的模型数据、材质等打包发送给GPU
4. 发送SetPassCall和Drawcall告诉GPU渲染管线渲染模型数据所需的shader
5. 数据在GPU渲染管线中绘制，将3D物体渲染为2D图像
6. 将渲染图像存放在帧缓冲区（FrameBuffer）中。可以理解为一个和屏幕大小等大的临时画布
7. 后处理操作。通过CPU拿到帧缓冲区的图像，调用shader再进入GPU渲染管线，对帧缓冲区的图像进行二次的修改，比如调色、bloom等操作
8. 显示在屏幕上

CPU应用程序端逻辑：经过剔除、排序等等，将模型数据打包发给GPU渲染管线
GPU渲染管线：拿到模型数据后，讲图像画出来，存放在对应的帧缓冲区中

![](p3.png "CPU打包数据") <br>

# GPU渲染管线

0. CPU打包数据：vertex buffer/index buffer/frustum视锥/directional light平行光/texture+shader
    • SetPass Call：设定好渲染设置后，告诉GPU使用哪个shader，使用哪种混合模式、设置背面剔除等等，当使用不同的材质或者相同的材质下不同的Pass时需要设置切换多个渲染状态，就会增加SetPassCall，所以SetPassCall的次数也能反映性能
    • Draw Call（绘制调用）：CPU打包数据发送给GPU，告诉GPU使用哪些模型数据进行渲染
1. Vertex Shader: 使用顶点/视锥信息将模型空间变换到屏幕空间
2. Triangle Processing 图元装配：把顶点信息按照缓存连接成三角形图元
3. Rasterization：插值计算出三角形每个像素的深度/颜色
4. Pixel Shader (i.e. Fragment Shader)：根据灯光/纹理贴图采样
5. Frame Buffer：post processing 抗锯齿 校色 景深（DOF） 动态模糊

![](p1.jpg "全览图") <br>

# 图元 vs 片元

* 图元

渲染图元（rendering primitives）为图形渲染开发接口中用来描述各种图形元素的图形数据，所对应的就是绘图界面上看得见的实体，它包括了渲染所需的几何信息，可以是顶点数据、线段、多边形等。

![](p4.png "图元的数据类型") <br>

图元至少要包含一个顶点（Vertex）；一个顶点定义了2D或3D坐标系中一个点，也同样定义了若干个可以影响如何把顶点渲染到屏幕上的属性，如：

![](p5.png "图元顶点所包含的信息") <br>

* 片元

在GPU流水线中的三角形遍历阶段，将会检查每个像素是否被一个三角网格所覆盖；如果被覆盖的话，就会生成一个片元（fragment）；需要注意的是，一个片元并不是真正意义上的像素，而是包括了很多状态的集合，这些状态用于计算每个像素的最终颜色；这些状态包括了（但不限于）它的屏幕坐标、深度信息，以及其它从几何阶段输出的顶点信息，例如法线、纹理坐标等。

---

# Credits

https://blog.csdn.net/lel18570471704/article/details/134708949
https://zhuanlan.zhihu.com/p/667522425
https://zhuanlan.zhihu.com/p/407046161
图元vs片元：https://blog.csdn.net/DoomGT/article/details/115806364

---